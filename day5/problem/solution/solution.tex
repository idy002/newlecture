\documentclass[11pt,serif]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xeCJK}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usetheme{Boadilla}
\begin{document}
	\author{丁尧尧}
	\title{Solution}
	\subtitle{day1}
	\date{\today}
	
	\begin{frame}[plain]
		\maketitle
	\end{frame}

	\begin{frame}{color}
		\begin{solution}
			我们把连在一起的同一种颜色的点缩成一个点,这样我们得到一棵树树,我们的答案一定是这棵树的直径上的点数除以二向上取整(为了能让直径合并成同一个点,必须要这么多次操作,而这么多次操作也足够了)
		\end{solution}
	\end{frame}

	\begin{frame}{grow} 
		\begin{solution}
			虽然$2^30$巨大,但因为$t$很小,所以它走不远,能走到的点总数很小,直接记忆一下以前走过的状态,如果以前走过,则不重复去走.
		\end{solution}	
	\end{frame}

	\begin{frame}{year}
		\begin{solution}
			这道题我没有想到有什么贪心做法.
			
			给定一个串用$dp$解决是很显然的,然后我们发现这个dp状态很小(我们用$dp[i]$表示,匹配到了$2016$的第$i$位,并且没出现$2017$这种状态最少删除多少个字符).
			
			然后我们就可以用线段树来维护这个dp
			
			因为线段树需要合并,我们不能保证每次的初始状态是0,故我们还需要假设前驱状态是什么.
			
		\end{solution}
	\end{frame} 

\end{document}